// This file is part of Metaplay SDK which is released under the Metaplay SDK License.

using Akka.Actor;
using Metaplay.Cloud.Entity.PubSub;
using Metaplay.Core;
using Metaplay.Core.Message;
using Metaplay.Core.Model;
using Metaplay.Core.Serialization;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using static Metaplay.Cloud.Sharding.EntityShard;

namespace Metaplay.Cloud.Entity
{
    /// <summary>
    /// Topic on which an entity is subscribed to another entity. Can be used to distinguish
    /// which messages are published to which subscribers.
    /// </summary>
    // \todo [petri] most definitions should be userland, use DynamicEnum?
    [MetaSerializable]
    public enum EntityTopic
    {
        Owner = 0,
        Visitor,
        Member,
        Participant,
        Spectator,

        Last,
    }

    /// <summary>
    /// Entity subscription topic flags. Can be used as a mask when publishing messages to
    /// multiple topics.
    /// </summary>
    [Flags]
    public enum EntityTopicFlags
    {
        None    = 0,                            // Empty flags
        Owner   = 1 << EntityTopic.Owner,       // Owner of player state
        All     = ~0
    }

    /// <summary>
    /// The base type for an entity PubSub subscription (in both ways).
    /// </summary>
    public class EntityPubSubState
    {
        /// <summary>
        /// EntityId of the peer entity.
        /// </summary>
        public EntityId     EntityId        { get; private set; }

        /// <summary>
        /// ActorRef of the peer entity.
        /// </summary>
        public IActorRef    ActorRef        { get; private set; }

        /// <summary>
        /// Incarnation of the peer entity (If entity restarts, this changes).
        /// </summary>
        public int          IncarnationId   { get; private set; }

        /// <summary>
        /// Local shard's bookkeeping Id.
        /// </summary>
        public int          PubSubId        { get; private set; }

        /// <summary>
        /// Topic on which the subscription is on
        /// </summary>
        public EntityTopic  Topic           { get; private set; }

        /// <summary>
        /// ChannelId for incoming messages (generated by self)
        /// </summary>
        public int          InChannelId     { get; private set; }

        /// <summary>
        /// ChannelId for outgoing messages (generated by peer)
        /// </summary>
        public int          OutChannelId    { get; private set; }

        MetaDictionary<Type, object> _userDataByType;

        public EntityPubSubState(EntityId entityId, IActorRef actorRef, int incarnationId, int pubSubId, EntityTopic topic, int inChannelId, int outChannelId)
        {
            EntityId        = entityId;
            ActorRef        = actorRef;
            IncarnationId   = incarnationId;
            PubSubId        = pubSubId;
            Topic           = topic;
            InChannelId     = inChannelId;
            OutChannelId    = outChannelId;

            _userDataByType = new MetaDictionary<Type, object>();
        }

        /// <summary>
        /// Sets or overwrites an user data of type T. This data can be retrieved with <see cref="GetUserData{T}"/>.
        /// </summary>
        /// <remarks>
        /// The data is set exactly for type <typeparamref name="T"/> and no other type. Specifically, it can be
        /// retrieved only with type <typeparamref name="T"/> and not with its sub- or base-class types or by
        /// interface type.
        /// <para>
        /// There is individual user data for each type T. User data for types T and T' are independent. The
        /// presence or non-presence of user data for type T does not affect the user data for type T'.
        /// </para>
        /// <code>
        /// // Multiple user data
        /// SetUserData&lt;MySubscriptionState&gt;( ... );
        /// SetUserData&lt;MyOtherSubscriptionState&gt;( ... );
        /// // User data co-exist and are independent
        /// GetUserData&lt;MySubscriptionState&gt;(); // returns MySubscriptionState
        /// GetUserData&lt;MyOtherSubscriptionState&gt;(); // returns MyOtherSubscriptionState
        /// GetUserData&lt;MyThirdSubscriptionState&gt;(); // throws, not set
        /// </code>
        /// </remarks>
        public void SetUserData<T>(T userData) where T : class
        {
            _userDataByType.AddOrReplace(typeof(T), userData);
        }

        /// <summary>
        /// Retrieves the user data set with <see cref="SetUserData{T}(T)"/>. If no user data is set for the type, an exception is thrown.
        /// </summary>
        /// <remarks>
        /// <inheritdoc cref="SetUserData{T}(T)"/>
        /// </remarks>
        public T GetUserData<T>() where T : class
        {
            if (_userDataByType.TryGetValue(typeof(T), out object value))
                return (T)value;
            throw new InvalidOperationException($"Attempted to GetUserData<{typeof(T).ToGenericTypeString()}>() without calling SetUserData<{typeof(T).ToGenericTypeString()}>() first");
        }

        /// <summary>
        /// Retrieves the user data set with <see cref="SetUserData{T}(T)"/>. If no user data is set for the type, returns <c>null</c>.
        /// </summary>
        /// <remarks>
        /// <inheritdoc cref="SetUserData{T}(T)"/>
        /// </remarks>
        public bool TryGetUserData<T>(out T userData) where T : class
        {
            if (_userDataByType.TryGetValue(typeof(T), out object value))
            {
                userData = (T)value;
                return true;
            }
            userData = null;
            return false;
        }
    }

    /// <summary>
    /// Represents a subscriber for a given entity.
    /// </summary>
    public class EntitySubscriber : EntityPubSubState
    {
        public EntitySubscriber(EntityId entityId, IActorRef actorRef, int incarnationId, int pubSubId, EntityTopic topic, int inChannelId, int outChannelId) : base(entityId, actorRef, incarnationId, pubSubId, topic, inChannelId, outChannelId)
        {
        }
    }

    /// <summary>
    /// Represents state of subscription to a specific entity.
    /// </summary>
    public class EntitySubscription : EntityPubSubState
    {
        public EntitySubscription(EntityId entityId, IActorRef actorRef, int incarnationId, int pubSubId, EntityTopic topic, int inChannelId, int outChannelId) : base(entityId, actorRef, incarnationId, pubSubId, topic, inChannelId, outChannelId)
        {
        }
    }

    partial class EntityActor
    {
        static readonly Prometheus.Counter              c_entityUnsubscribes            = Prometheus.Metrics.CreateCounter("game_entity_unsubscribes_total", "Total amount of entity subscriptions ended by target entity type", "target");
        static readonly Prometheus.Counter              c_entitySubscriberKicked        = Prometheus.Metrics.CreateCounter("game_entity_subscribers_kicked_total", "Total amount of entity subscriptions ended by getting kicked (by target entity type)", "target");

        protected Dictionary<int, EntitySubscriber>     _subscribers                    = new Dictionary<int, EntitySubscriber>();
        protected Dictionary<int, EntitySubscription>   _subscriptions                  = new Dictionary<int, EntitySubscription>();

        int                                             _runningChannelId               = 1;        // RunningId for subscription channels

        // Temporary state for the duration of OnNewSubscriber
        EntitySubscriber                                _ongoingNewSubscriber           = null;
        List<PubSub.PubSubMessage>                      _ongoingNewSubscriberMsgQueue   = null;

        void RegisterPubSubHandlers()
        {
            ReceiveAsync<PubSub.EntitySubscribeS2ESubscribeRequest>(ReceiveEntitySubscribeS2ESubscribeRequest);
            ReceiveAsync<PubSub.WatchedEntityTerminated>(ReceiveWatchedEntityTerminated);
            ReceiveAsync<PubSub.EntitySubscribeS2EUnsubscribeRequest>(ReceiveEntitySubscribeS2EUnsubscribeRequest);
            ReceiveAsync<PubSub.EntitySubscribeS2EKickMessage>(ReceiveEntitySubscribeS2EKickMessage);
            ReceiveAsync<PubSub.PubSubMessage>(ReceivePubSubMessage);
        }

        async Task ReceiveEntitySubscribeS2ESubscribeRequest(EntitySubscribeS2ESubscribeRequest subscribe)
        {
            MetaMessage message = null;
            if (!subscribe.Message.IsEmpty)
                message = subscribe.Message.Deserialize(resolver: null, logicVersion: null);

            try
            {
                // Allocate incoming channel & create subscriber
                int inChannelId = _runningChannelId++;
                EntitySubscriber newSubscriber = new EntitySubscriber(subscribe.SubscriberEntityId, subscribe.SubscriberActor, subscribe.SubscriberIncarnationId, subscribe.PubSubId, subscribe.Topic, inChannelId, subscribe.SubscriberChannelId);

                _log.Debug("New subscriber: {SubscriberId} / {SubscriberActor} out:${ChannelId} in:${SelfChannelId} [{Topic}]", subscribe.SubscriberEntityId, subscribe.SubscriberActor, subscribe.SubscriberChannelId, inChannelId, subscribe.Topic);

                // Mark that we are currently processing a subscription.
                _ongoingNewSubscriber = newSubscriber;

                // Handle new subscriber
                // \note store subscriber after handling it (so won't get sent messages if handler publishes)
                MetaMessage response;
                try
                {
                    response = await OnNewSubscriber(newSubscriber, message);
                }
                catch (EntityAskRefusal error) when (error.OriginEntity == EntityId.None)
                {
                    // Handler threw a controlled exception, propagate to caller
                    error.OriginEntity = _entityId;
                    Tell(_shard, EntitySubscribeS2ESubscribeResponse.Failure(
                        pubSubId:           subscribe.PubSubId,
                        subscribedEntityId: _entityId,
                        error:              error));

                    // Drop pooled messages
                    if (_ongoingNewSubscriberMsgQueue != null)
                    {
                        foreach (PubSub.PubSubMessage envelope in _ongoingNewSubscriberMsgQueue)
                            _log.Warning("PubSub Message to {Peer} dropped because message was sent from handler that then rejected the Subscription. Message type: {MessageType}.", subscribe.SubscriberEntityId, MetaSerializationUtil.PeekMessageName(envelope.Payload));
                        _ongoingNewSubscriberMsgQueue = null;
                    }
                    _ongoingNewSubscriber = null;
                    return;
                }
                _subscribers.Add(inChannelId, newSubscriber);

                // Send response
                MetaSerialized<MetaMessage> serializedResponse = MetaSerialization.ToMetaSerialized(response, MetaSerializationFlags.IncludeAll, logicVersion: null);
                Tell(_shard, EntitySubscribeS2ESubscribeResponse.Success(
                    pubSubId:           subscribe.PubSubId,
                    subscribedEntityId: _entityId,
                    subscribedChannelId:inChannelId,
                    subscribedActor:    _self,
                    reply:              serializedResponse));

                AfterNewSubscribersInternal();

                // Flush pooled messages
                if (_ongoingNewSubscriberMsgQueue != null)
                {
                    foreach (PubSub.PubSubMessage envelope in _ongoingNewSubscriberMsgQueue)
                        Tell(newSubscriber.ActorRef, envelope);
                    _ongoingNewSubscriberMsgQueue = null;
                }
                _ongoingNewSubscriber = null;
            }
            catch (Exception ex)
            {
                // Respond with error & crash
                Tell(_shard, EntitySubscribeS2ESubscribeResponse.Failure(
                    pubSubId:           subscribe.PubSubId,
                    subscribedEntityId: _entityId,
                    error:              new UnexpectedEntityAskError(_entityId, "OnNewSubscriber()", ex)));
                throw;
            }
        }

        async Task ReceiveWatchedEntityTerminated(PubSub.WatchedEntityTerminated terminated)
        {
            EntityId entityId = terminated.EntityId;

            // Resolve all lost subscribers & subscriptions (take copies to avoid mutating dictionaries while traversing)
            // \todo [petri] allocates empty lists when no matching entities
            List<EntitySubscriber> lostSubscribers = new List<EntitySubscriber>();
            List<EntitySubscription> lostSubscriptions = new List<EntitySubscription>();
            foreach (EntitySubscriber subscriber in _subscribers.Values)
            {
                if (subscriber.EntityId == terminated.EntityId && subscriber.IncarnationId == terminated.IncarnationId)
                    lostSubscribers.Add(subscriber);
            }
            foreach (EntitySubscription subscriptions in _subscriptions.Values)
            {
                if (subscriptions.EntityId == terminated.EntityId && subscriptions.IncarnationId == terminated.IncarnationId)
                    lostSubscriptions.Add(subscriptions);
            }

            _log.Info("Watched entity {EntityId} terminated unexpectedly. {NumSubscribers} subscriber(s) and {NumSubscriptions} subscription(s) lost.",
                entityId,
                lostSubscribers.Count,
                lostSubscriptions.Count);

            // Handle lost subscribers (if any)
            foreach (EntitySubscriber subscriber in lostSubscribers)
            {
                _subscribers.Remove(subscriber.InChannelId);
                await OnSubscriberTerminatedAsync(subscriber);
                await OnSubscriberLostAsync(subscriber);
            }

            // Handle lost subscriptions (if any)
            foreach (EntitySubscription subscription in lostSubscriptions)
            {
                _subscriptions.Remove(subscription.InChannelId);
                await OnSubscriptionLostAsync(subscription);
            }

            if (lostSubscribers.Count > 0)
                AfterSubscribersLostInternal();
        }

        async Task ReceiveEntitySubscribeS2EUnsubscribeRequest(EntitySubscribeS2EUnsubscribeRequest request)
        {
            bool wasRemoved;
            if (_subscribers.Remove(request.InChannelId, out EntitySubscriber lostSubscriber))
            {
                _log.Debug("Entity {SubscriberId} unsubscribed ${ChannelId} [{Topic}] with goodbye={GoodbyeMessage}", lostSubscriber.EntityId, request.InChannelId, lostSubscriber.Topic, MetaSerializationUtil.PeekMessageName(request.GoodbyeMessage));
                wasRemoved = true;

                MetaMessage goodbyeMessage = null;
                if (!request.GoodbyeMessage.IsEmpty)
                    goodbyeMessage = request.GoodbyeMessage.Deserialize(resolver: null, logicVersion: null);

                await OnSubscriberUnsubscribedAsync(lostSubscriber, goodbyeMessage);
                await OnSubscriberLostAsync(lostSubscriber);
            }
            else
            {
                // \note This can happen if subscriber unsubscribes as it is kicked
                _log.Info("Received Unsubscribe from unknown subscriber ${ChannelId}: {SubscriberId}", request.InChannelId, request.SubscriberId);
                wasRemoved = false;
            }

            Tell(_shard, new EntitySubscribeS2EUnsubscribeResponse(
                subscribedEntityId: _entityId,
                pubSubId:           request.PubSubId,
                wasSuccess:         wasRemoved
                ));

            if (wasRemoved)
                AfterSubscribersLostInternal();
        }

        async Task ReceiveEntitySubscribeS2EKickMessage(EntitySubscribeS2EKickMessage kicked)
        {
            if (!_subscriptions.Remove(kicked.ChannelId, out EntitySubscription subscription))
            {
                _log.Info("Kicked from unknown entity subscription. Channel ${ChannelId}: {Message}", kicked.ChannelId, MetaSerializationUtil.PeekMessageName(kicked.GoodbyeMessage));
                return;
            }

            MetaMessage message = null;
            if (!kicked.GoodbyeMessage.IsEmpty)
                message = kicked.GoodbyeMessage.Deserialize(resolver: null, logicVersion: null);
            await OnSubscriptionKickedAsync(subscription, message);
        }

        async Task ReceivePubSubMessage(PubSub.PubSubMessage envelope)
        {
            EntityId fromEntityId = envelope.FromEntityId;

            if (_subscriptions.TryGetValue(envelope.ChannelId, out EntitySubscription subscription))
            {
                MetaMessage msg = envelope.Payload.Deserialize(resolver: null, logicVersion: null);
                Type msgType = msg.GetType();

                if (_dispatcher.TryGetPubSubSubscriptionDispatchFunc(msgType, out var pubSubDispatchFunc))                  await pubSubDispatchFunc(this, subscription, msg).ConfigureAwait(false);
                else if (_dispatcher.TryGetMessageDispatchFunc(msgType, out var msgDispatchFunc))                           await msgDispatchFunc(this, fromEntityId, msg).ConfigureAwait(false);
                else if (_dispatcher.TryGetPubSubSubscriptionDispatchFunc(typeof(MetaMessage), out pubSubDispatchFunc))     await pubSubDispatchFunc(this, subscription, msg).ConfigureAwait(false);
                else                                                                                                        await HandleUnknownMessage(fromEntityId, msg).ConfigureAwait(false);
            }
            else if (_subscribers.TryGetValue(envelope.ChannelId, out EntitySubscriber subscriber))
            {
                MetaMessage msg = envelope.Payload.Deserialize(resolver: null, logicVersion: null);
                Type msgType = msg.GetType();

                if (_dispatcher.TryGetPubSubSubscriberDispatchFunc(msgType, out var pubSubDispatchFunc))                await pubSubDispatchFunc(this, subscriber, msg).ConfigureAwait(false);
                else if (_dispatcher.TryGetMessageDispatchFunc(msgType, out var msgDispatchFunc))                       await msgDispatchFunc(this, fromEntityId, msg).ConfigureAwait(false);
                else if (_dispatcher.TryGetPubSubSubscriberDispatchFunc(typeof(MetaMessage), out pubSubDispatchFunc))   await pubSubDispatchFunc(this, subscriber, msg).ConfigureAwait(false);
                else                                                                                                    await HandleUnknownMessage(fromEntityId, msg).ConfigureAwait(false);
            }
            else
            {
                _log.Info("Received PubSub message from {EntityId} on unknown channel ${ChannelId}: {MessageType}", fromEntityId, envelope.ChannelId, MetaSerializationUtil.PeekMessageName(envelope.Payload));
            }
        }

        void AfterSubscribersLostInternal()
        {
            TryScheduleShutdownAfterSubscriberLoss();
        }

        void AfterNewSubscribersInternal()
        {
            TryCancelShutdownAfterNewSubscriber();
        }

        /// <summary>
        /// Subscribes to an entity. This forms an communication channel between this entity and the target entity, allowing target
        /// to send messages to this, and other subscribers, by using <see cref="PublishMessage(EntityTopic, MetaMessage)"/> on the
        /// provided <paramref name="topic"/>.
        /// <para>
        /// The <paramref name="message"/> is delivered on target entity's <see cref="OnNewSubscriber(EntitySubscriber, MetaMessage)"/>
        /// and the return value from that method is delivered back as the return value of this method. If target entity rejects the
        /// subscription by throwing an <see cref="EntityAskRefusal"/> in the <see cref="OnNewSubscriber(EntitySubscriber, MetaMessage)"/> handler,
        /// the exception is delivered to caller entity and thrown from this method's invocation.
        /// </para>
        /// <para>
        /// Throws:
        /// <list type="bullet">
        /// <item><see cref="EntityAskRefusal"/> if target entity refuses the subscription</item>
        /// <item><see cref="TimeoutException"/> if reply is not received within the timeout</item>
        /// <item><see cref="UnexpectedEntityAskError"/> if target entity crashes in subscription handling</item>
        /// <item><see cref="EntityCrashedError"/> if target entity crashes before handling the message</item>
        /// <item><see cref="EntityUnreachableError"/> if the message couldn't be delivered to the target entity</item>
        /// </list>
        /// </para>
        /// </summary>
        /// <param name="allowMultiple">
        /// If false, attempting to subscribe to an entity that is already subscribed to will fail with <see cref="InvalidOperationException"/>.
        /// This is false by default as duplicate subscriptions are likely a mistake.
        /// </param>
        protected async Task<(EntitySubscription, TResult)> SubscribeToAsync<TResult>(EntityId targetEntityId, EntityTopic topic, MetaMessage message, bool allowMultiple = false, TimeSpan timeout = default) where TResult : MetaMessage
        {
            if (timeout == default)
                timeout = TimeSpan.FromMilliseconds(10_000);

            // Check for valid target
            if (!targetEntityId.IsValid)
                throw new ArgumentException($"targetEntityId must be a valid entity (got {targetEntityId})", nameof(targetEntityId));

            // Check against duplicate subscriptions to target
            if (!allowMultiple && _subscriptions.Values.Any(sub => sub.EntityId == targetEntityId))
                throw new InvalidOperationException($"Already subscribed to {targetEntityId} [{topic}]");

            // Allocate channelId for incoming messages & begin subscribe to target
            int inChannelId = _runningChannelId++;
            TaskCompletionSource<PubSub.EntitySubscribeE2SSubscribeRequest.SubscribeAck> replyPromise = new ();
            MetaSerialized<MetaMessage> serializedMsg = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(_shard, new PubSub.EntitySubscribeE2SSubscribeRequest(
                targetEntityId:     targetEntityId,
                subscriberEntityId: _entityId,
                subscriberActor:    _self,
                topic:              topic,
                channelId:          inChannelId,
                message:            serializedMsg,
                replyPromise:       replyPromise
                ));

            // Track metrics. We use the Ask-duration historgram.
            string askMetricsLabel;
            if (message != null)
                askMetricsLabel = $"Subscribe-{targetEntityId.Kind.Name}-{MetaMessageRepository.Instance.GetFromType(message.GetType()).Name}";
            else
                askMetricsLabel = $"Subscribe-{targetEntityId.Kind.Name}";
            Stopwatch sw = Stopwatch.StartNew();

            c_entityAsks.WithLabels(askMetricsLabel).Inc();

            // Wait for response (or timeout)
            Task<PubSub.EntitySubscribeE2SSubscribeRequest.SubscribeAck> task = replyPromise.Task;
            Task finished = await Task.WhenAny(task, Task.Delay(timeout));
            PubSub.EntitySubscribeE2SSubscribeRequest.SubscribeAck ack;

            if (finished == task)
            {
                c_entityAskDuration.WithLabels(askMetricsLabel).Observe(sw.Elapsed.TotalSeconds);

                // Propagate exceptions due to failed routing/handling
                if (task.IsFaulted)
                {
                    // \note This flattening code is duplicated in EntityActor.EntityAskAsync

                    AggregateException flattened = task.Exception.Flatten();
                    Exception effectiveException = flattened.InnerException is EntityAskExceptionBase askException ? askException : flattened;
                    if (!(effectiveException is EntityAskRefusal))
                        c_entityAskErrors.WithLabels(askMetricsLabel, "exception").Inc();

                    throw effectiveException;
                }

                ack = task.GetCompletedResult();
            }
            else
            {
                c_entityAskErrors.WithLabels(askMetricsLabel, "timeout").Inc();

                // \note: We are no longer waiting for the subscription, but the shards and the target entity
                //        may not know it. They may observe the subscription as successfully opened. This is
                //        acceptable: If this entity handles TimeoutException, it will try again later, succeed,
                //        and this half-open subscription shouldn't cause problems.

                string messageTypeStr;
                if (message != null)
                    messageTypeStr = message.GetType().ToGenericTypeString();
                else
                    messageTypeStr = "null";
                throw new TimeoutException($"Timeout during SubscribeToAsync<{typeof(TResult).ToGenericTypeString()}>({messageTypeStr}) from {_entityId} to {targetEntityId}");
            }

            // Store subscription (using subsciber's channelId)
            EntitySubscription subscription = new EntitySubscription(targetEntityId, ack.TargetActor, ack.IncarnationId, ack.PubSubId, topic, inChannelId, ack.ChannelId);
            _subscriptions.Add(inChannelId, subscription);

            // Handle response type
            MetaMessage response = ack.Response.Deserialize(resolver: null, logicVersion: null);
            if (response == null)
                return (subscription, null);
            else if (response is TResult typed)
                return (subscription, typed);
            else
            {
                c_entityAskErrors.WithLabels(askMetricsLabel, "invalidResponse").Inc();
                throw new InvalidOperationException($"Invalid response type for SubscribeToAsync<{typeof(TResult).ToGenericTypeString()}> from {_entityId} to {targetEntityId}: got {response.GetType().ToGenericTypeString()} (expecting {typeof(TResult).ToGenericTypeString()})");
            }
        }

        [Obsolete("Use the statically-typed overload. Note that TResult may be MetaMessage.")]
        protected Task<(EntitySubscription, MetaMessage)> SubscribeToAsync(EntityId targetEntityId, EntityTopic topic, MetaMessage message)
        {
            // \note prefer statically-typed SubscribeToAsync<TResponse> when response value type is known beforehand
            return SubscribeToAsync<MetaMessage>(targetEntityId, topic, message);
        }

        /// <summary>
        /// Unsubscribes from the entity and waits until the target entity acknowledges the delivery of all the messages
        /// this entity has sent to the pubsub channel. This invokes the <see cref="OnSubscriberLostAsync(EntitySubscriber)"/> and <see cref="OnSubscriberUnsubscribedAsync(EntitySubscriber, MetaMessage)"/>
        /// hooks on the target entity.
        /// <para>
        /// On success, returns true. If Unsubscribe message couldn't be guaranteed to have been delivered to the target entity, returns false.
        /// Message delivery can fail for example if the target entity terminates abnormally, or has already kicked this subscriber.
        /// </para>
        /// <para>
        /// If no confirmation is needed of the completion, you don't need to await the result but can invoke the method as fire-and-forget: <code>_ = UnsubscribeFromAsync(subscription)</code>
        /// </para>
        /// </summary>
        /// <param name="goodbyeMessage">
        /// Message delivered to <see cref="OnSubscriberUnsubscribedAsync(EntitySubscriber, MetaMessage)"/> handler.
        /// Can be used to communicate the reason for unsubscribing.
        /// </param>
        protected async Task<bool> UnsubscribeFromAsync(EntitySubscription subscription, MetaMessage goodbyeMessage = null)
        {
            TimeSpan timeout = TimeSpan.FromMilliseconds(10_000);

            if (!_subscriptions.Remove(subscription.InChannelId, out EntitySubscription existing) || !ReferenceEquals(subscription, existing))
                throw new InvalidOperationException($"Trying to unsubscribe unknown subscription to {subscription.EntityId} ${subscription.InChannelId}");

            MetaSerialized<MetaMessage> goodbyeBlob;
            if (goodbyeMessage != null)
                goodbyeBlob = new MetaSerialized<MetaMessage>(goodbyeMessage, MetaSerializationFlags.IncludeAll, null);
            else
                goodbyeBlob = MetaSerialized<MetaMessage>.Empty;

            // Begin unsubscribe from target
            TaskCompletionSource<PubSub.EntitySubscribeE2SUnsubscribeRequest.UnsubscribeResult> replyPromise = new ();
            Tell(_shard, new PubSub.EntitySubscribeE2SUnsubscribeRequest(
                subscriberEntityId: _entityId,
                pubSubId:           existing.PubSubId,
                goodbyeMessage:     goodbyeBlob,
                replyPromise:       replyPromise
                ));

            // Track metrics. We use the Ask-duration historgram.
            string targetTypeStr = subscription.EntityId.Kind.Name;
            string askMetricsLabel = $"Unsubscribe-{subscription.EntityId.Kind.Name}";
            Stopwatch sw = Stopwatch.StartNew();

            c_entityUnsubscribes.WithLabels(targetTypeStr).Inc();

            // Wait for response (or timeout)
            // \note: To support FIRE AND FORGET use mode, we don't mutate state after this point.
            //        We use ConfigureAwait, so to run the rest of the method on non-actor-exclusive scheduler.
            Task<PubSub.EntitySubscribeE2SUnsubscribeRequest.UnsubscribeResult> task = replyPromise.Task;
            Task finished = await Task.WhenAny(task, Task.Delay(timeout)).ConfigureAwait(false);

            if (finished == task)
            {
                c_entityAskDuration.WithLabels(askMetricsLabel).Observe(sw.Elapsed.TotalSeconds);

                // Propagate exceptions due to failed routing/handling
                if (task.IsFaulted)
                {
                    // peer crashed during or before unsub request, or unroutable.
                    return false;
                }

                EntitySubscribeE2SUnsubscribeRequest.UnsubscribeResult result = task.GetCompletedResult();
                return result == EntitySubscribeE2SUnsubscribeRequest.UnsubscribeResult.Success;
            }
            else
            {
                // timeout. Cannot guarantee success
                _log.Warning("Timeout during UnsubscribeFromAsync({Topic}) from {EntityId} to {TargetEntityId}", subscription.Topic, _entityId, subscription.EntityId);
                return false;
            }
        }

        /// <summary>
        /// Removes the specified subscriber from this entity. This causes <see cref="OnSubscriptionKickedAsync"/>
        /// to be (eventually) called on the kicked entity with the specified message.
        /// </summary>
        /// <param name="subscriber">the subscriber to be removed</param>
        /// <param name="message">kick message delivered to the subscriber</param>
        protected void KickSubscriber(EntitySubscriber subscriber, MetaMessage message)
        {
            if (subscriber == null)
                throw new ArgumentNullException(nameof(subscriber));

            // Try to remove subscriber
            bool hadSuchSubscriber = _subscribers.Remove(subscriber.InChannelId);
            if (!hadSuchSubscriber)
                return;

            c_entitySubscriberKicked.WithLabels(subscriber.EntityId.Kind.ToString()).Inc();

            MetaSerialized<MetaMessage> goodbyeBlob;
            if (message != null)
                goodbyeBlob = new MetaSerialized<MetaMessage>(message, MetaSerializationFlags.IncludeAll, null);
            else
                goodbyeBlob = MetaSerialized<MetaMessage>.Empty;

            Tell(_shard, new EntitySubscribeE2SKickMessage(
                kickerEntityId: _entityId,
                pubSubId:       subscriber.PubSubId,
                goodbyeMessage: goodbyeBlob
                ));

            AfterSubscribersLostInternal();

            OnSubscriberKicked(subscriber, message);
        }

        /// <summary>
        /// Direct send message over a subscription channel.
        /// </summary>
        /// <param name="subscription">Subscription over which to send the message</param>
        /// <param name="message">Message to send</param>
        protected void SendMessage(EntitySubscription subscription, MetaMessage message)
        {
            if (subscription == null)
                throw new ArgumentNullException(nameof(subscription));
            if (message == null)
                throw new ArgumentNullException(nameof(message));

            MetaSerialized<MetaMessage> serialized = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(subscription.ActorRef, new PubSub.PubSubMessage(_entityId, subscription.OutChannelId, serialized));
        }

        /// <summary>
        /// Direct send message over a subscription channel. Calling this during <see cref="OnNewSubscriber" /> for the
        /// new yet-to-be-added subscriber causes the message to be queued until the OnNewSubscriber returns, and only
        /// then flushed on the added subscriber channel.
        /// </summary>
        /// <param name="subscriber">Subscriber to which to send the message</param>
        /// <param name="message">Message to send</param>
        protected void SendMessage(EntitySubscriber subscriber, MetaMessage message)
        {
            if (subscriber == null)
                throw new ArgumentNullException(nameof(subscriber));
            if (message == null)
                throw new ArgumentNullException(nameof(message));

            MetaSerialized<MetaMessage> serialized = new MetaSerialized<MetaMessage>(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            PubSub.PubSubMessage envelope = new PubSub.PubSubMessage(_entityId, subscriber.OutChannelId, serialized);

            if (!ReferenceEquals(subscriber, _ongoingNewSubscriber))
            {
                // existing subscriber channel
                Tell(subscriber.ActorRef, envelope);
            }
            else
            {
                // sending to a channel that is just about to be created. We accepted the subscriber but we haven't
                // replied yet. Buffer the messages until we reply to the request.
                _ongoingNewSubscriberMsgQueue = _ongoingNewSubscriberMsgQueue ?? new List<PubSub.PubSubMessage>();
                _ongoingNewSubscriberMsgQueue.Add(envelope);
            }
        }

        /// <summary>
        /// Publish message to all subscribers on a set of topics.
        /// </summary>
        /// <param name="flags">Bitmask of topics to send message to</param>
        /// <param name="message">Message to send</param>
        protected void PublishMessage(EntityTopicFlags flags, MetaMessage message)
        {
            // Message is serialized lazily (for first actual receiver)
            MetaSerialized<MetaMessage> serialized = new MetaSerialized<MetaMessage>();

            foreach (EntitySubscriber subscriber in _subscribers.Values)
            {
                if (((1u << (int)subscriber.Topic) & (uint)flags) != 0)
                {
                    if (serialized.IsEmpty)
                        serialized = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);

                    Tell(subscriber.ActorRef, new PubSub.PubSubMessage(_entityId, subscriber.OutChannelId, serialized));
                }
            }
        }

        /// <summary>
        /// Publish a message to subscribers on a given topic.
        /// </summary>
        /// <param name="topic">Topic on which to publish message on</param>
        /// <param name="message">Message to publish</param>
        protected void PublishMessage(EntityTopic topic, MetaMessage message)
        {
            PublishMessage((EntityTopicFlags)(1 << (int)topic), message);
        }

        /// <summary>
        /// Called just before a new subscriber to this entity is added.
        /// <para>
        /// If this method throws an <see cref="EntityAskRefusal"/>, the subcription is refused instead.
        /// In that case, the subscription is not added and the exception will be delivered to the
        /// caller-entity's call-site <see cref="SubscribeToAsync{TResult}(EntityId, EntityTopic, MetaMessage, bool, TimeSpan)"/>,
        /// where it will be thrown.
        /// </para>
        /// <para>
        /// Throwing a refusal does not crash this actor. This actor will remain alive.
        /// </para>
        /// </summary>
        /// <param name="subscriber">the new subscription</param>
        /// <param name="message">the message supplied in <see cref="SubscribeToAsync"/>, if any</param>
        /// <returns>the message supplied to <see cref="SubscribeToAsync"/> return value, if any</returns>
        protected virtual Task<MetaMessage> OnNewSubscriber(EntitySubscriber subscriber, MetaMessage message) => Task.FromResult<MetaMessage>(null);

        /// <summary>
        /// Called after a subscriber to this entity is removed. This is due to the subscriber either terminating
        /// or calling <see cref="UnsubscribeFromAsync"/>.
        /// <para>
        /// See also:
        /// <seealso cref="OnSubscriberTerminatedAsync(EntitySubscriber)"/>
        /// <seealso cref="OnSubscriberUnsubscribedAsync(EntitySubscriber, MetaMessage)"/>
        /// </para>
        /// </summary>
        /// <param name="subscriber">the terminated subscription</param>
        protected virtual Task OnSubscriberLostAsync(EntitySubscriber subscriber) => Task.CompletedTask;

        /// <summary>
        /// Called after a subscriber to this entity is removed due to the subscriber entity terminating.
        /// This method is called just before <see cref="OnSubscriberLostAsync"/>.
        /// <para>
        /// See also:
        /// <seealso cref="OnSubscriberLostAsync(EntitySubscriber)"/>
        /// <seealso cref="OnSubscriberUnsubscribedAsync(EntitySubscriber, MetaMessage)"/>
        /// </para>
        /// </summary>
        /// <param name="subscriber">the terminated subscription</param>
        protected virtual Task OnSubscriberTerminatedAsync(EntitySubscriber subscriber) => Task.CompletedTask;

        /// <summary>
        /// Called after a subscriber to this entity is removed due to the subscriber calling <see cref="UnsubscribeFromAsync"/>.
        /// This method is called just before <see cref="OnSubscriberLostAsync"/>.
        /// The <paramref name="goodbyeMessage"/> is the optional message given to <see cref="UnsubscribeFromAsync"/>.
        /// <para>
        /// See also:
        /// <seealso cref="OnSubscriberLostAsync(EntitySubscriber)"/>
        /// <seealso cref="OnSubscriberTerminatedAsync(EntitySubscriber)"/>
        /// </para>
        /// </summary>
        /// <param name="subscriber">the terminated subscription</param>
        /// <param name="goodbyeMessage">the goodbye message given to UnsubscribeFromAsync</param>
        protected virtual Task OnSubscriberUnsubscribedAsync(EntitySubscriber subscriber, MetaMessage goodbyeMessage) => Task.CompletedTask;

        /// <summary>
        /// Called after a subscriber is kicked by calling <see cref="KickSubscriber" />. Useful in conjunction with <see cref="OnSubscriberLostAsync(EntitySubscriber)"/>
        /// to track all events where a subscriber is removed from an entity.
        /// </summary>
        /// <remarks>
        /// This method is called synchronously from <see cref="KickSubscriber" />.
        /// </remarks>
        /// <param name="subscriber">the kicked subscriber</param>
        /// <param name="message">the message specified in KickSubscriber, if any</param>
        protected virtual void OnSubscriberKicked(EntitySubscriber subscriber, MetaMessage message) { }

        /// <summary>
        /// Called after a subscription to an entity is terminated due to the entity terminating.
        /// </summary>
        /// <param name="subscription">the terminated subscription</param>
        protected virtual Task OnSubscriptionLostAsync(EntitySubscription subscription)
        {
            _log.Warning("Unhandled lost subscription to {TargetActor} [{Topic}]", subscription.ActorRef, subscription.Topic);
            return Task.CompletedTask;
        }

        /// <summary>
        /// Called after a subscription to an entity is terminated due to the entity calling <see cref="KickSubscriber" />.
        /// </summary>
        /// <param name="subscription">the terminated subscription</param>
        /// <param name="message">the message specified in KickSubscriber, if any</param>
        protected virtual Task OnSubscriptionKickedAsync(EntitySubscription subscription, MetaMessage message)
        {
            _log.Debug("Kicked from entity {EntityId} channel ${ChannelId} [{Topic}]: {MessageName}", subscription.EntityId, subscription.InChannelId, subscription.Topic, message?.GetType().Name ?? "<empty>");
            return Task.CompletedTask;
        }
    }
}
